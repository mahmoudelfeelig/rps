const MinefieldSession = require('../models/MinefieldSession');
const User             = require('../models/User');

const ROWS  = 8;
const COLS  = 8;
const MINES = 10;

// POST /api/games/minefield/start
exports.startRound = async (req, res) => {
  try {
    const userId     = req.user.id;
    const { betAmount } = req.body;

    if (!betAmount || betAmount <= 0) {
      return res.status(400).json({ message: 'Invalid bet amount' });
    }

    // 1) Refund any unfinished round
    const prev = await MinefieldSession.findOne({ user: userId, ended: false });
    if (prev) {
      prev.ended     = true;
      prev.cashedOut = true;
      await prev.save();

      const refundUser = await User.findById(userId);
      refundUser.balance += prev.betAmount;
      await refundUser.save();
    }

    // 2) Debit this new bet
    const user = await User.findById(userId);
    if (user.balance < betAmount) {
      return res.status(400).json({ message: 'Insufficient funds' });
    }
    user.balance -= betAmount;
    await user.save();
    const updatedBalance = user.balance;

    // 3) Create the session
    const session = await MinefieldSession.create({
      user:      userId,
      betAmount,  // dynamic
      // mines are generated by the model’s default
    });

    return res.json({
      sessionId:  session._id,
      rows:       ROWS,
      cols:       COLS,
      betAmount:  session.betAmount,
      revealed:   session.revealedCells,
      minesCount: session.mines.length,
      balance:    updatedBalance
    });
  } catch (err) {
    console.error('Minefield start error:', err);
    return res.status(500).json({ message: 'Could not start minefield round' });
  }
};

// POST /api/games/minefield/reveal
exports.revealCell = async (req, res) => {
  const { sessionId, cellIndex } = req.body;

  try {
    const session = await MinefieldSession.findById(sessionId);
    if (!session || session.user.toString() !== req.user.id) {
      return res.status(404).json({ message: 'Session not found' });
    }
    if (session.ended) {
      return res.status(400).json({ message: 'Round already ended' });
    }
    if (session.revealedCells.includes(cellIndex)) {
      return res.status(400).json({ message: 'Cell already revealed' });
    }

    session.revealedCells.push(cellIndex);

    // hit a mine → end the round immediately
    if (session.mines.includes(cellIndex)) {
      session.ended    = true;
      session.exploded = true;
      await session.save();
      return res.json({
        exploded: true,
        mines:    session.mines
      });
    }

    // safe click → increment safeCount
    session.safeCount += 1;
    await session.save();

    // exponential multiplier: 1.2 ^ safeCount
    const multiplier      = Math.pow(1.2, session.safeCount);
    const potentialReward = Math.floor(session.betAmount * multiplier);

    return res.json({
      exploded:        false,
      safeCount:       session.safeCount,
      potentialReward
    });
  } catch (err) {
    console.error('Reveal cell error:', err);
    return res.status(500).json({ message: 'Could not reveal cell' });
  }
};

// POST /api/games/minefield/cashout
exports.cashOut = async (req, res) => {
  const { sessionId } = req.body;

  try {
    const session = await MinefieldSession.findById(sessionId);
    if (!session || session.user.toString() !== req.user.id) {
      return res.status(404).json({ message: 'Session not found' });
    }
    if (session.ended) {
      return res.status(400).json({ message: 'Round already ended' });
    }

    // exponential multiplier: 1.2 ^ safeCount
    const multiplier = Math.pow(1.2, session.safeCount);
    const reward     = Math.floor(session.betAmount * multiplier);

    // credit user
    const user = await User.findById(req.user.id);
    user.balance += reward;
    await user.save();
    const updatedBalance = user.balance;

    // mark session ended
    session.ended     = true;
    session.cashedOut = true;
    await session.save();

    return res.json({
      reward,
      balance: updatedBalance
    });
  } catch (err) {
    console.error('Cash out error:', err);
    return res.status(500).json({ message: 'Could not cash out' });
  }
};